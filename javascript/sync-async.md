# Sync-Async

서버 어플리케이션 하나의 처리 성능을 증가시키기 위해 고려되는 것 중 하나는 request를 처리하는 thread가 작업을 처리할 때 비동기로 작동하도록 하는지이다. 우선 동기와 비동기에 대한 차이를 알아보자.

### 동기 (Syncronous)

동기처리는 하나의 thread가 request를 처리할 때 해당 request에 필요한 작업들이 완료될 때 까지 매번 대기하게 된다. 예를 들면, 서버에서 데이터베이스에 CRUD를 요청한다면 동기 처리 thread는 데이터베이스로 부터 완료 응답이 올 때 까지 다른 일을 하지 못한다. 다른 IO작업이나 다른 서버로 request를 보내는 일 또한 응답이 올 때 까지 대기한다.
이러한 특징 때문에 절차적으로 프로그래밍하기는 쉽지만 요청이 많아질 수록 `C10K problem`과 같은 이슈가 발생하게 된다.

> #### C10K problem
>
> 하나의 서버가 1만개의 클라이언트를 동시에 처리할 수 있는지에 대한 의문으로 UNIX 계열의 OS에서 I/O 모델의 미비로 인해 제기 되었다고 한다.

### 비동기 (Asyncronous)

비동기처리는 동기 처리와 반대로 작업이 완료될 때 까지 대기하지 않고 다른 요청을 받는다. 동기 방식보다 상대적으로 적은 thread를 사용하면서도 많은 양의 request를 처리할 수 있는 핵심이 이런 이유에서이다. 예를 들면, javascript 엔진의 event loop를 생각해보자. Web API를 통해 비동기 함수나 콜백 함수등을 호출할 때 완료를 대기하지 않고 바로 다음 작업을 수행하게 된다. 이 또한 javascript가 단일 thread로 하나의 call stack을 가지지만 성능이 좋은 이유이다.

> Web API는 브라우저의 thread가 별도로 실행하는 것이기 때문에 모든 작업이 하나의 thread로 실행된다고 생각하면 안된다.
> javascript 엔진의 thread가 Web API thread에 비동기 작업들을 위임한다고 생각하자
> 완료된 작업은 Task Queue(=Callback Qeueue)에 쌓이게 되고 Call Stack의 작업이 없을 때 Task Queue의 나머지 작업을 Call Stack에 적재하여 실행하게 된다.

다른 예로는 Tomcat의 디폴트 스레드는 200로 한번에 200개의 요청밖에 처리할 수 없지만 Netty를 통해 비동기로 요청을 받게 되면 더 많은 처리가 가능해진다.

### 효율적으로 사용하기
javascript에서는 callback, Promise, async/await과 같이 여러가지 비동기 처리 방식이 존재한다. async/await 은 ES6부터 등장한 키워드로 기존의 callback, Promise의 무한 들여쓰기를 보완해주기 때문에 비동기 처리를 가독성이 좋은 코드로 작성할 수 있게 되었다. 하지만 비동기의 원리를 간과하고 단순히 async함수 내에서 await를 마구 사용한다면 해당 함수는 비동기로 실행될 지 몰라도 함수 내부의 await를 사용한 비동기 함수들은 동기적으로 실행된다. 물론 의도에 따라 순차적으로 실행되야 한다면 올바른 방법이지만, 굳이 순차적으로 실행될 필요가 없거나 응답이 필요없는 경우 Promise.all()과 같은 방법으로 실행하는 것이 효율적이다.